//Questions
// Question 1. Какой оператор сравнения использует switch? 
// Question 2. Яке ключове слово зупиняє процес порівняння в switch?
// Question 3. Чи буде показано alert?
// if ("0") {
//     console.log( 'Привіт' );
//   }

// -----Цикли-----
// Цикл – це спосіб повторити один і той же код кілька разів.

/*---while - спочатку думаємо - потім робимо. Доки умова є вірною, виконується код із тіла циклу. 
Одне виконання циклу називається ітерацією.
Цикл в зразку нижче робить десять ітерацій. */
// let i = 0;
// while (i < 10) {
//     console.log('i = ' + i++);
// }

//Цикл while може закінчитися, так і не розпочавшись
while(false){
    console.log('А я все одно щось зроблю ?');
}
console.log('Кінець завдання');

//А може й затягнутися (не треба так робити)
// while(true){
// 	console.log('А я все одно щось зроблю ');
//     break;
// }
// console.log('Кінець завдання');

//Наприклад, коротший спосіб написання while (i != 0) відповідає while (i):
// let i = 10;
// while (i) { // коли i буде 0, умова стане невірною, і цикл зупиниться
//     console.log( i );
//     i--;
// }

//Якщо тіло цикла має тільки одну операцію, ми можемо опустити фігурні дужки {…}:
// let i = 10;
// while (i) console.log(i--);

/*----do...while - спочатку робимо, потім думаємо.
Цикл спочатку виконує тіло, а потім перевіряє умову, і поки умова є true, цикл виконується знову і знову.*/
var i = 0;
do {
    i += 2; 
    console.log("i = " + i);
} while (i < 5);
console.log("Після закінчення циклу i = " + i); 

// do...while обов'язково відпрацює хоча б раз!
// do{
//     console.log("А я все одно щось зроблю");
// } while(false);

//-------------------------------------------------------------------------------------------------------------------------
// ----- Цикл For. Виглядає він так: for (початок; умова; крок) {

// for (var i = 0; i < 9; i++) {   // початок - var i = 0. Виконується один раз, при вході в цикл. 
//                                 //умова - i < 9.Перевіряється перед кожною ітерацією циклу. Якщо умова невірна, цикл зупиняєтья.
//                                 // тіло - console.log('лічильник циклу i= ' + i);. Виконується знову і знову, поки умова є правдивою (true).
//                                 // крок - i++. Виконується після тіла на кожній ітерації, але перед перевіркою умови.
//     console.log('лічильник циклу i= ' + i);
// }
// console.log("Після закінчення циклу i = " + i);

/* Будь-яку частину for можна пропустити.
 Приклад без початку */
// let i = 0; // ми вже маємо оголошену змінну і присвоєне значення
// for (; i < 5; i++) { // немає необхідності в "початку"
//     console.log( i ); 
// }

// Приклад без кроку. Це робить цикл ідентичним до while (i < 5).
// let i = 0;
// for (; i < 5;) {
//     console.log( i++ );
// }

/*Можна взагалі забрати все, отримавши нескінченний цикл. 
Зауважте, що ці двокрапки ; повинні бути, інакше виникне синтаксична помилка. */
// for (;;) {
//     // буде вічно повторюватися
//     console.log( "hi");
//   }

/*---break, continue - ручне керування циклом
Зазвичай, цикл завершується, коли умова стає false.
Але ми можемо в будь-який момент вийти з циклу, використавши спеціальну директиву break */
// var i = 0;
// for (; ;) {
//     if (i === 3) {
//         console.log("Дійшли до 3");
//         break;
//     }
//     console.log(i);
//     i++;
// }
// console.log("Після закінчення циклу i = " + i);

// Можна і так
for (let i = 5; i--;){
    console.log(i); // Так, а чому 4 ?
}

/* continue – пропускаємо хід. Виводимо лише парні
Директива continue — це “полегшена версія” break. Вона не зупиняє весь цикл. 
Натомість, вона зупиняє поточну ітерацію і починає виконання циклу спочатку з наступної ітерації (якщо умова циклу досі вірна).
Її зручно використовувати коли закінчили з поточною ітерацією і хочемо продовжити з наступної.*/

/*Для парних значень змінної i, директива continue зупиняє виконання тіла циклу і передає контроль наступній ітерації в for (в цьому випадку це буде наступне число). 
Таким чином функція alert викликається лише для непарних значень змінної i. */
for (let x = 0; x < 10; x++) {
    if (x % 2) continue;   // якщо умова справджується, тоді пропускаємо решту тіла циклу і починаємо з наступної ітерації
    console.log('тільки парні: х = ' + x);
}
console.log("Як це ще може виглядати");

for (let x = 0; x < 10; x++) {
    if (x % 2 === 0) console.log('тільки парні: х = ' + x);
}

//Цікаво, а що буде якщо ми покладемо один for, до іншого!
// Уявімо що ми хочемо створити таблицю множення на 5
let number = 5;
for (let i = 1; i <= 9; i++){
    console.log("Результат множення " + number + " * " + i + " = " + number * i);
}

// Тепер я хочу зробити всю таблицю множення
for (let i = 1; i <= 9; i++){ //1 2
    for (let j = 1; j <= 9; j++){ //1 2 3
        console.log("Результат множення " + i + " * " + j + " = " + i * j);
    }
    console.log("----------------------------")
}

// А якщо я хочу множити тільки парне значення
// for (let i = 1; i <= 9; i++){
//     if (i % 2) continue;
//     for (let j = 1; j <= 9; j++){
//         console.log("Результат множення " + i + " * " + j + " = " + i * j);
//     }
//     console.log("----------------------------")
// }

//---Мітки для циклів---
// Деколи нам потрібно вийти з кількох вкладених циклів.
// label: for (let i = 1; i <= 9; i++) {
//     for (let j = 1; j <= 9; j++) {
//         if (j === 5) {
//             console.log("----------------------------")
//             continue label;
//         }
//         console.log("Результат множення " + i + " * " + j + " = " + i * j);
//     }
// }

//-------------------------------------------------------------------------------------------------------------------------
/**
 Functions
 Функції - це блоки коду, які можна викликати з будь-якого місця у програмі.
 Вони дозволяють згрупувати певний фрагмент коду і використовувати його в багатьох місцях
 без необхідності повторювати сам код.

 У JavaScript є кілька способів визначення функцій:
 - Function Declaration
 - Function Expression
 - Arrow Functions
 */

// ---Класичний випадок - Function Declaration---

// function test() {   //Оголошення функції
//     console.log("Привіт із функції!");  //Тіло функції
// }
// console.log("Зараз викличемо функцію");
// test(); // виклик функції
// test(); // виклик функції
// test(); // виклик функції

//Додамо щось цікавіше ніж console.log. Давайте розрахуємо площу квадрату
// function squareAreaCalculation() {
//    // let a = prompt("Ввести сторону квадрату");
//     let a = 4;
//     console.log(a * a);
// }
// squareAreaCalculation();

//Функція – єдиний спосіб створити локальну область видимості
/*var ext = "Зовнішня змінна";

function test() {
    var inner = "Тільки для внутрішнього користування";
    console.log('Бачу: ext=' + ext);
    console.log('Бачу: inner=' + inner);
}
test();*/
/*console.log('А тепер – зовні:')
console.log('Бачу: ext='+ext);
console.log('Бачу: inner='+inner);*/

//Своя сорочка ближче до тіла (народна мудрість)
//  var ext = "Зовнішня змінна";

// function test() {
//     var ext = "Внутрішня змінна";
//     console.log('Змінна ext=' + ext);
// }

// test();
// console.log('Змінна ext=' + ext);

//Усередині функції змінні "спливають" точно так, як і в основному скрипті
/*function test() {
    console.log('Спочатку myVar дорівнювала ' + myVar);
    myVar = "Я маю значення!";
    console.log('потім myVar=' + myVar);
    var myVar;
}

test();*/


/* ---Function Expression. Він дозволяє створювати функцію всередині будь-якого виразу.
Зауважте, після ключового слова function немає назви функції. Для функціональних виразів це допустимо. */
// let squareArea = function() {
//    // let a = prompt("Ввести сторону квадрату");
//    let a = 2; 
//    console.log(a * a);
// }
// squareArea();

// А в чому тоді різниця
/*printGreeting(); // І в нас ніяких проблем;
function printGreeting() {
    console.log("Hello world")
}*/

// А що ми тут отримаємо ?
/*printGreeting()
let printGreeting = function () {
    console.log("Hello world")
}*/

// А якщо так ?
/*printGreeting();
var printGreeting = function () {
    console.log("Hello world")
}*/

// Function Expression корисно використовувати коли ми хочемо в змінній зберігати різні функції
// let autoBrand = "ТАВРІЯ";
// let accelerateСar;
// switch (autoBrand) {
//     case "Audi":
//         accelerateСar = function () {
//             let audiSpeedIndex = 100;
//             console.log("Розганяємо авто до 150км: " + audiSpeedIndex * 1.5);
//         }
//         break;
//     case "ТАВРІЯ":
//         accelerateСar = function () {
//             let audiSpeedIndex = 0;
//             console.log("Розганяємо авто до 150км")
//             for (let i = 0; i < 60; i += 10) {
//                 audiSpeedIndex += i;
//                 console.log(audiSpeedIndex);
//             }
//         }
//         break;
// }

// accelerateСar();

// Це все чудово, але є певні загальні рекомендації що і як повинна містити функція.
/*function squareAreaCalculation() {
    let a = prompt("Ввести сторону квадрату"); // Нечиста функція через побічний ефект
    let result = a * a;
    console.log(result);  // Нечиста функція через побічний ефект
}*/

// Тепер трохи краще, але...
/*let a = prompt("Ввести сторону квадрату");

function squareAreaCalculation() {
    let result = a * a;
}

console.log(result);*/ // Але ми тут не бачимо нашу змінну.

// ---Поняття return---- В якості результату, функція може повертати назад значення в код, який викликав цю функцію.

// Розглянемо що повертає функція за замовчуванням
// let a = 5;
// function squareAreaCalculation() {
//     let result = a * a;
// }
// console.log(squareAreaCalculation())

// let a = 5;
// function squareAreaCalculation() {
//     let result = a * a; // Але все одно погано що ми маємо залежність через використання зовнішньої змінної:
//     return result;
// }
// let result = squareAreaCalculation();
// console.log(result);

/* Директива return може бути в будь-якому місці функції. Коли виконання досягає цієї директиви, функція зупиняється, 
і в код, який викликав цю функцію, повертається значення (в прикладі вище, це значення присвоюється змінній result) 
return - це безумовний вихід із функції 
// */
// let a = 5;
// function squareAreaCalculation() {
//     let result = a * a; // Але все одно погано що ми маємо залежність через використання зовнішньої змінної:
//     return result;
//     console.log("After return");
// }
// let result = squareAreaCalculation();
// console.log(result);

//В одній функції може бути декілька директив return. Наприклад:
// function checkAge() {
//     let age = 19;
//     if (age >= 18) {
//       return console.log('У вас є дозвіл');
//     } else {
//       return console.log('У вас є дозвіл ваших батьків?');
//     }
//   }
//   checkAge();

//Можна використовувати return без значення. Це призведе до негайного виходу з функції.
// function showMovie() {
//      let age = 10;
//     if ( age <= 18 ) {
//       return;
//     }
//     console.log( "Показуємо фільм" );  //В коді вище, якщо if поверне false, тоді функція showMovie не дійде до виконання console.log.
//   }
//   showMovie()

/* --- Найменування функції---
Функції виконують дії. Тому в їхніх іменах зазвичай використовують дієслова. Ім’я повинне бути лаконічним, повинне якнайточніше описувати, що робить функція, щоб кожен хто читає код зміг зрозуміти, що саме робить функція.

Поширена практика розпочинати ім’я функції зі словесного префіксу, який описує дію. В команді має бути домовленість щодо значення префіксів.

Наприклад, функції, які починаються з префіксу "show" зазвичай щось показують.

Функції, які починаються з …
- "get…" – повертають значення,
- "calc…" – щось обчислюють,
- "create…" – щось створюють,
- "check…" – щось перевіряють і повертають булеве значення.

Ось приклади таких імен:
showMessage(..)     // показує повідомлення
getAge(..)          // повертає вік (якось його отримує або обчислює)
calcSum(..)         // обчислює суму і повертає результат
createForm(..)      // створює форму (і зазвичай її повертає)
checkPermission(..) // перевіряє доступ, повертає true/false
*/

/* Одна функція – одна дія
Функція повинна робити саме те, що написано в її імені, не більше.
Дві незалежні дії зазвичай заслуговують двох функцій, навіть якщо вони зазвичай викликаються разом 
(у цьому випадку ми можемо створити 3-ю функцію, яка викликає ці дві).

Ось декілька прикладів, які порушують це правило:
- getAge – функція викликає alert з віком (а повинна лише отримувати вік).
- createForm – функція змінює документ, додаючи форму до неї (а повинна лише створити форму і її вернути).
- checkPermission – функція відображає повідомлення доступ надано/відхилено (а повинна лише повертати результат true/false).

Ці приклади передбачають загальне значення префіксів. Ви та ваша команда можете вільно домовлятися про інші значення, але зазвичай вони не сильно відрізняються. 
У будь-якому випадку ви повинні чітко розуміти, що означає префікс, що може робити префіксна функція, а що ні. Усі функції з однаковими префіксами повинні підкорятися правилам. 
І команда повинна ділитися знаннями.
*/

/* ---Передача значень у функцію---
Ми можемо передати в функцію довільні дані використовуючи параметри.
*/


// function squareAreaCalculation(side) {
//     return side * side;
// }
// let result = squareAreaCalculation(5);
// console.log(result);

// А що буде якщо я не передам нічого
// function squareAreaCalculation(side) {
//     console.log(side);
//     return side * side;
// }
// let result = squareAreaCalculation();
// console.log(result);

// Параметрів можна вказувати скільки завгодно
// function hello(name, surname, age){
//     console.log("Hello " + name + " " + surname + ", your age is " + age);
// }
// hello('Dmitro', 'Tuchina', 12 );

//А можна якось встановити параметри за замовчуванням, або що робити якщо нам нічого не передали
// function hello(name, surname) {
//     let greet = 'Hello ';
//     name = name || 'John Snow';
//     if (surname)
//         greet += name + ' ' + surname;
//     else
//         greet += name;
//     return greet;
// }
// console.log(hello());
// console.log(hello('Volodimir'));
// console.log(hello('Dmitro', 'Sirko'));

// Інший варіант як можна задати значення за замовчуванням
// function hello(name = 'default123456') {
//     return   'Hello ' + name;
// }
// console.log(hello());
// console.log(hello('Volodimir'));


/*Функціональний Вираз проти Оголошення Функції
Функціональний Вираз буде створено тільки тоді, коли до нього дійде виконання і тільки після цього він може бути використаний.
Синтаксис Оголошення Функції дозволяє викликати функцію раніше, ніж вона були визначена в коді
Наприклад, глобальне Оголошення Функції буде доступним з будь-якого місця в скрипті.
Така поведінка спричинена особливостями внутрішніх алгоритмів. Коли JavaScript готується до виконання скрипта, 
він спочатку шукає всі глобальні Оголошення Функцій і на їх основі створює функції. 
Цей процес можна вважати “фазою ініціалізації”.
Після того, як всі Оголошення Функцій були оброблені, рушій починає виконання коду.
*/

//Це, наприклад, буде працювати:

sayHi("Foxy"); 
// function sayHi(name) {
//     console.log( `Привіт, ` + name );
// }

//…З Функціональним Виразом це не спрацювало б:
// sayHi("Foxy"); 
// let sayHi = function(name) {  
//     console.log( `Привіт, ` + name );
// };

/* ---Стрілкові функції---
Це так звані “стрілкові функції”, а виглядають вони ось так: 
let func = (arg1, arg2, ..., argN) => expression;
Цей код створить функцію func з аргументами arg1..argN, що обчислює expression з правого боку (використовуючи ці аргументи) та повертає його результат.
*/

let sum = (a, b) => a + b; //Як ви бачите, (a, b) => a + b означає функцію, яка приймає два аргументи a і b. Після запуску, вона виконає вираз a + b і поверне результат.
console.log( sum(5, 9) ); 
/*
* Ця стрілкова функція — це коротша форма для:

let sum = function(a, b) {
  return a + b;
};
*/

//Стрілкові функції можна використовувати тим самим способом, що й Функціональні Вирази.

// let age = 22;

// let welcome = (age < 18) ?
//   () => console.log('Привіт') :
//   () => console.log("Вітання!");

// welcome();


//Якщо функція має лише один аргумент, тоді дужки навколо параметрів можна опускати, що дозволить записати її ще коротше.
// let multiply = n => n * 4; // те ж саме, що і: let double = function(n) { return n * 2 }
// console.log(multiply(5));

//Якщо аргументів немає, то дужки порожні, але вони повинні бути:
// let sayHi = () => console.log("Привіт!");
// sayHi();


// -----Круто!!! А можу я щось передавати окрім значень! Так - callback function (функції зворотного виклику)!-----

// уявимо таку ситуацію
// function myDisplayer(sentence) {
//     console.log("Результат - " + sentence);
//   }
  
//   function myCalculator(num1, num2) {
//     let sum = num1 + num2;
//     return sum;
//   }
  
//   let result = myCalculator(5, 4);
//   myDisplayer(result);



// чи можна зробити так
// function myDisplayer(sentence) {
//     console.log("Результат - " + sentence);
//   }
  
//   function myCalculator(num1, num2) {
//     let sum = num1 + num2;
//     myDisplayer(sum);
//   }
  
//   myCalculator(5, 4);



// давайте переробимо под колбек

function myDisplayer(sentence) {
    console.log("Результат - " + sentence);
  }
  
  function myCalculator(num1, num2, myCallback) {
    let sum = num1 + num2;
    myCallback(sum);
  }
  
  myCalculator(5, 5, myDisplayer);



//Функція розганяє нашу автівку
/*function accelerateCar(callbackFunction, maxSpeed) {
    let carSpeed = 0;
    while (carSpeed <= maxSpeed){
        callbackFunction(carSpeed++);
    }
}

accelerateCar(console.log, 200);*/
