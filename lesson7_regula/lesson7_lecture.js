//Регулярні вирази

/*  
    Регулярний вираз (RegExp) - це шаблон, який використовується для пошуку та заміни тексту в рядках. 
    Він складається з послідовності символів, які визначають певний шаблон, який потрібно знайти в тексті. 
    Регулярні вирази використовуються в багатьох програмах, таких як пошукові системи, текстові редактори, утиліти обробки тексту, лексичний аналіз та інші.

    Регулярні вирази підтримуються в багатьох мовах програмування, таких як JavaScript, Python, PHP, Java та інші. 
    Вони використовуються для пошуку та заміни тексту в рядках, а також для валідації даних та інших завдань обробки тексту.
*/

/* var str = "миші, щури, знову миші, хом'яки, ховрахи";
var re = /щури/; // це RegExp. Слеші /.../ говорять JavaScript про те, що це регулярний вираз. Вони відіграють тут ту саму роль, що й лапки для позначення рядків.
console.log(typeof re);
console.log(str.search(re)); // Шукаємо шаблон у рядку
console.log(str.search(/кіт/)); // А якщо не знайшли ?
console.log(re.test(str)); */ // метод test() використовуеться для перевірки, чи зустрічається цей підрядок у рядку str. Якщо метод test() повертає true, це означає, що підрядок "щури" знайдено у рядку str.


//Однак поки що не сталося нічого, чого не міг би зробити indexOf();
/* var str1 = "vasja@yahoo.com";
var str2 = "petja@gmail.com";
var re = /@gmail|@urknet/ // значок | - внутрішній оператор мови регулярних виразів, що позначає "або"
console.log(str1 + ': ' + str1.search(re)); // Не знайшли
console.log(str2 + ': ' + str2.search(re)); // Знайшли

console.log("Тестуємо перший рядок: " + re.test(str1)); //І у зворотний бік
console.log("Тестуємо другий рядок: " + re.test(str2)); */  //Якось менш інформативно – тільки так чи ні.

//Перелік альтернативних варіантів можна укласти в дужки 
/* var str1 = "vasja@yahoo.com";
var str2 = "petja@gmail. com"; //зверніть увагу: тут помилка!
var str3 = "petja@gmail.com"; 
var re = /(@gmail|@urknet).com/; // З точкою тут не все так просто
console.log(str1 + ': ' + re.test(str1));
console.log(str2 + ': ' + re.test(str2));
console.log(str3 + ': ' + re.test(str3)); */

/*
    Припустимо, ми хочемо знайти буквально точку. Не "будь-який символ", а саме крапку.
    Щоб використовувати спеціальний символ як звичайний, додайте до нього зворотну косу риску: \..
    Це називається "екранування символу".
*/

/* var str1 = "vasja@yahoo.ua";
var str3 = "petja@gmail.com"; 
var str2 = "petja@gmailcom"; 
var re = /\.com/;
console.log(str1 + ': ' + re.test(str1));
console.log(str3 + ': ' + re.test(str3)); 
console.log(str3 + ': ' + re.test(str2));  */

/* var str1 = "Строка з /";
var re = /\//;
console.log(str1 + ': ' + re.test(str1)); */

/* var str1 = "Строка з \\";
var re = /\\/;
console.log(str1 + ': ' + re.test(str1)); */

//var str1 = "моя улюбена книга \"Вололад Перснів\""

//Спеціальні символи. Крапка "." - будь-який символ
/* var str = "ivanov_ruslan@yahoo.com";
var re = /.com/;
console.log(str + " - " + re.test(str)); //Очікувано повертає true
//Змінимо адресу
str = "ivanov_commer@gmail";
console.log(str + " - " + re.test(str));   */

/* var str = "У цьому вся тексті зустрічається символ \" | \". Як знайти його через регулярний вираз?";
console.log(str);
var re = /\||\./; //Звичайно ж - екранувати, Таким чином, цей регулярний вираз відповідатиме будь-якому символу | або . в рядку.
console.log("Тестуємо:" + re.test(str)); */

//Можемо шукати діапазони значень
/* var str = "vasja@gmail.com";
var re = /[bcdi]/; //Регулярний вираз /[bcdi]/ вказує на пошук будь-якого символу, який відповідає будь-якому з символів "b", "c", "d" або "i". 
console.log(re.test(str)); //Поверне правду, якщо у рядку є хоча б один символ із зазначеного набору. У цьому випадку, метод test() повернув true, оскільки в рядку str знайдено символ "i", який відповідає одному з символів у наборі [bcdi].
console.log(str.search(re));  */

/* 
    /[a-z]/ діапазон значень від a до z. Тобто - всі малі англійські літери
    /[0-9]/ всі цифри
    /[a-zA-Z0-9]/ загалом усі літери латинського алфавіту, а разом із ними ще й цифри
    
    Скорочення
    / \d / Те саме, що і [0-9]
    / \w / те ж, що [a-zA-Z0-9_] всі літери англійського алфавіту, цифри та знак підкреслення
    / \s / різні "пробільні" символи 
*/


//Спокійно можемо комбінувати обидва підходи – і це вже цікаво
/* var str = "Сьогодні 6 день неділі";
var re = /[1-7asd] день неділі/;
console.log(re.test(str));
console.log(str.search(re)); */

//діапазон "крім"
/* var str = "Дуже довгий рядок, в якому немає англійських букв і цифр";
// var str = "Loremipsum";
var re = /[^\w]/; // Чи є щось, крім англійського алфавіту та цифр?
console.log(re.test(str));
console.log(str.search(re)); */  // І справді, перший (нульовий) символ не підходить під шаблон.

/* var str = "Дуже довгий рядок, в якому немає англійських букв і цифр";
//var str = "дуже";
var re = /[^а-я]/; //чи є в нас великі літери
console.log("Друга спроба: " + re.test(str));
console.log(str.search(re)); */ // І справді, перша літера - велика!

// \ D - все, крім цифр
// \ W - Крім букв, цифр і _
// \S - крім пробілових символів

// Однак усередині групи точка – це лише точка.
// /[.+()]/  просто символи
// /[-[^]/  теж просто символи, хоча все могло бути інакше, якби вони стояли на інших місцях!

//Можемо вказати кількість повторень
/* console.log(/abc/.test("abbc")); //false
console.log(/ab{2,4}c/.test("abc")); //вказує на пошук підрядка, який починається з "a", за яким слідує від 2 до 4 символів "b", а потім "c", занадто мало b
console.log(/ab{2,4}c/.test("abbbbbc")); //занадто багато b
console.log(/ab{2,4}c/.test("abbbc")); //true - в самий раз
console.log(/ab{2,}c/.test("abbbbbbbbbbbbc"));//два і більше
console.log(/ab{2,}c/.test("abc"));
console.log(/ab{2}c/.test("abc")); //Строго два
console.log(/ab{2}c/.test("abbc")); //Строго два
console.log(/ab{2}c/.test("abbbc")); //Строго два */


//Для часто використовуваних є скорочення
/* console.log(/ab?c/.test("abc")); //   вираз вказує на пошук підрядка, що починається з "a", за яким може слідувати нуль або один символ "b", а потім "c".
console.log(/ab?c/.test("ac")); // теж годиться
console.log(/ab?c/.test("abbc")); */

/* var re = /ab+c/; //пошук що починається з "a", за яким може слідувати один або або більше символів "b", а потім "c". 
console.log(re.test("abc"));
console.log(re.test("abbbbbbbbbbbbbbbbbbbbc"));
console.log(re.test("ac"));  */


/* var re = /ab*c/; //{0,} Або немає, або є скільки завгодно
console.log(re.test("abc"));
console.log(re.test("abbbbbbbbbbbbbbbbbbbbc"));
console.log(re.test("ac")); */

//Якоря: початок рядка ^ і кінець $

/* let str1 = "Mary had a little lamb";
// let str1 = "Belle had a little lamb";
let regex = /^Mary/
console.log( regex.test(str1) ); */

/* let str1 = "it's fleece was white as snow";
// let str1 = "Today was rain";
let regex = /snow$/
console.log( regex.test(str1) );  */

/* let goodInput = "12:34";
let badInput = "12:345";
let badInput1 = "012:345";

let regexp = /^\d\d:\d\d$/;
console.log( regexp.test(goodInput) ); 
console.log( regexp.test(badInput) ); 
console.log( regexp.test(badInput1) );  */


//Модифікатори, відповідальні за "кількість"  називаються квантифікаторами.
// Отже, знаємо: +, ?, * {}

//Практика: формати дат 
/* var strs = '31-05-2017';

var re = /(0[1-9]|1[1-9]\d|3[01])-(0[1-9]|1[021])-\d{4}/; // Помилка ?
console.log(re.test(strs));
console.log(strs.search(re)); */


/*var str = '14-04-2017';
var re = /(0[1-9]|[12]\d|3[01])-(0[1-9]|1[12])-\d{4}/;
console.log(re.test(str));

var str = '14-04-2017xcvxcvcv'; //А якщо так?
console.log(re.test(str));

var re = /^(0[1-9]|[12]\d|3[01])-(0[1-9]|1[12])-\d{4}$/; //Знайома нам галочка - але вже зовсім іншому значенні
console.log(re.test(str));*/

//Якщо у нас досить складний шаблон, нам часто може бути цікаво - що ж ми знайшли?
/* var str = " a--a abda acca ajttta ahgta avbga";
var re = /a[a-z]{2}a/; // пошук починається з символу "a", за яким слідує два символи латинського алфавіту, а потім знову символ "a"
console.log('Зразок: ' + str);
console.log(str.search(re));
console.log(str.match(re)); */ //match() повертає отримані збіги під час зіставлення рядка з регулярним виразом.

//Шукаємо щось, укладене у лапки
/* var str = 'У цьому рядку "рядку" буде два "місця", відзначені лапками';
var re = /".+"/; // пошук починається та закінчується подвійними лапками, і містить один або більше символів всередині лапок
console.log("Зразок: " + str);
console.log(str.match(re)[0]); */
// Можливо, ми хотіли побачити інший результат.

// Звичайно, ми можемо скласти шаблон інакше:
/* var str = 'У цьому рядку "рядку" буде два "місця", відзначені лапками';
var re = /"[^"]+"/;
console.log("Зразок: " + str);
console.log(str.match(re)[0]); */


/*
    /".+"/ - Цей вираз знайде найбільш довгий підрядок, який розташований між першою та останньою подвійною лапкою у рядку. 
    Це означає, що він може знайти підрядок, який містить інші подвійні лапки всередині себе, 
    оскільки він шукає будь-які символи між першою та останньою подвійною лапкою.

    /"[^"]+"/ - Цей вираз знайде найбільш короткий підрядок, який розташований між подвійними лапками. 
    Він виключить будь-які інші подвійні лапки всередині знайденого підрядка, оскільки використовується вираз [^"], 
    який відповідає будь-якому символу, крім подвійної лапки.
*/

// Ще приклад
/* const text = "aabab";
const regex = /a.*?b/; // лінивий пошук, починається з символу "a", містить будь-яку кількість символів (включаючи жоден) та закінчується символом "b".
const result = text.match(regex);
console.log(result);  */


/* Прапори регулярних виразів
    Регулярні вирази можуть мати прапори, які впливають на пошук або надають додаткову інформацію.

    У JavaScript їх усього сім:

    i - З цим прапором пошук не залежить від регістру: немає різниці між A і a (див. приклад нижче).
    g - Із цим прапором пошук шукає всі збіги, без нього - тільки перший.
    m - Багаторядковий режим (розглядається в розділі Багаторядковий режим якорів ^ $, прапор "m").
    s - Вмикає режим "dotall", за якого крапка . може відповідати символу переведення рядка \n (розглядається в розділі Символьні класи).
    u - Вмикає повну підтримку Юнікоду. Прапор дозволяє коректне опрацювання сурогатних пар (докладніше про це в розділі Юнікод: прапор "u" і клас \p{...}).
    y - Режим пошуку на конкретній позиції в тексті (описано в розділі Пошук на заданій позиції, прапор "y").
    d - З цим прапором результат регулярного виразу поміщається в масив, який містить додаткову інформацію про регулярний вираз, наприклад індекси початку і кінця підрядків. Цей прапор не змінює поведінку регулярного виразу, а лише надає додаткову інформацію.
*/

//Найпростіший випадок: реєстронезалежний пошук.
/* var str = "Ох вже ця вічна ВОзНЯ з регістром"
var re = /возня/i;
//var re = /возня/;

console.log("Знайшли щось? " + re.test(str));
console.log("А що саме? " + str.match(re)); */

//Знайдеться все. Наш перший приклад:
/* var str = "миші, щури, знову миші, хом'яки, ховрахи";
var re = /миші/;

var res = str.replace(re, "ховрахи");
console.log("Було: " + str + "\nСтало: " + res); */ // Заміна тільки перших мишей

/* var str = "миші, щури, знову миші, хом'яки, ховрахи";
var re = /миші/g;

var res = str.replace(re, "ховрахи");
console.log("Було: " + str + "\nСтало: " + res); */ // Заміна тільки перших мишей

// Ще один прапор - m (multiline)

/* let str = `1е місце: Іванко
2е місце: Михайло
3е місце: Ганна`;

console.log( str.match(/^\d/gm) ); */


/* let str = `1е місце: Іванко
2е місце: Михайло
3е місце: Ганна`;

console.log( str.match(/^\d/g) );  */// без прапора m було б знайдено тільки перше число:


/* var str = "abc\ndef\nghi";
var re = /^[a-z]/g; // Символ "^" вказує на початок рядка."[a-z]" вказує на будь-яку маленьку літеру англійського алфавіту.Модифікатор "g" вказує на глобальний пошук, тобто пошук всіх входжень, а не тільки першого.
var res = str.replace(re, "*");
console.log(res); */ // Як не крути, а "початок рядка" у нас тільки один

/* var str = "abc\ndef\nghi";
re = /^[a-z]/gm    // /gm вказує на багаторядковий режим, тобто пошук буде виконуватися для кожного рядка окремо.
res = str.replace(re, "*");
console.log(res);  */

/* let str = `Іванко: 1
Михайло: 2
Ганна: 3`;

console.log( str.match(/\d$/gm) ); */


//Цікаво впливає прапор g на match
/* var str = "шалені миші, щури, знову Миші, хом'яки, вуха, Суші, ховрахи";
var re = /[а-я]+ші/gi; //Флаги /g та /gi в регулярних виразах JavaScript вказують на глобальний пошук. Флаг /g використовується для пошуку всіх входжень в рядку, а не тільки першого. Флаг /i вказує на регістронезалежний пошук, тобто він ігнорує регістр символів під час пошуку. Отже, регулярний вираз /[а-я]+ші/gi буде шукати всі входження послідовностей кириличних символів, які закінчуються на "ші" у тексті, ігноруючи регістр символів.
var res = str.match(re);
console.log(res); */

//Посилання у регулярних виразах

/* var re = /['"][^'"]*['"]/; // Шукаємо щось, укладене в лапки (подвійні чи одинарні);
// var str="abc\"def\"ghijk";
// var str="abc\'def\'ghijk";
// var str = "abc\"def\'ghijk"; 
console.log(re.test(str));
console.log(str.match(re)); */


/*
    Частину шаблону можна укласти в дужки (...). Це називається "дужкова група".
    У такого виділення є два ефекти:
    - Дозволяє помістити частину збігу в окремий масив.
    - Якщо встановити квантифікатор після дужок, то він застосовуватиметься до всього вмісту дужки, а не до одного символу.
*/

/* var str = "Publication Date: 2021-09-06" //якщо ми хочемо отримати окремі компоненти дат - рік, місяць, день? У цьому випадку ми можемо скористатися групами
var re =  /(\d{4})-(\d{2})-(\d{2})/
var res = str.match(re);
console.log(res);   */

//До групи можна звернутися в шаблоні, використовуючи \N, де N - це номер групи.
/* let str = `He said: "She's the one!".`;
let regexp = /['"](.*?)['"]/g;
console.log( str.match(regexp) ); */ // Результат - не тот, который хотелось бы - "She'

//Для того, щоб шаблон шукав закриваючу лапку таку саму, як і відкриваючу, обгорнемо відкриваючі лапки в дужкову групу і використаємо зворотне посилання на неї: (['''])(.*?)\1.
/* let str = `He said: "She's the one!".`;
let regexp = /(['"])(.*?)\1/g;
console.log( str.match(regexp) ); */

/* var re = /(['"])[^'"]*\1/; // \1 вказує на повторення першої групи, тобто на лапки, які зберігаються в першій групі.
// var str = "abc\"def\"ghijk";
//var str = "abc'def'ghijk";
// var str = "abc\"def\'ghijk"; // вже не працює
console.log(re.test(str));
var res = str.match(re);
console.log(res);     */

// Ще приклад
/* var str ="шалені 'миші', \"щури\", знову 'миші', 'хом'яки', \"вуха\", Суші, ховрахи";
var re=/(['"])[^'"]+\1/g;
var res = str.match(re);
console.log(res); */

// і + вказує на повторення одного або більше разів, тоді як у другому виразі * вказує на повторення нуль або більше разів.

//Складніші посилання - зовнішні 
//Згаданий вище replase працює не тільки (і не стільки) з рядками, а й з регулярними виразами
var str = "12aaa54dfhj5546b4mn56bmi456mn456";
console.log("Зразок: " + str);

// var re = /\d+[a-z]+/; //пошуку послідовностей, які містять одну або більше цифру, за якою слідує одна або більше букв латинського алфавіту.
// var res = str.replace(re, '-+++-');
// console.log("Після редагування: " + res);

// А тепер ми хочемо не просто замінити знайдену групу, а поміняти місцями цифри та літери.
/* var re = /(\d+)([a-z]+)/g;
var res = str.replace(re, "|$2-$1|"); //змінює те що знайшли в регексі на |$2-$1|. |$2-$1| -(\d+) - $1, ([a-z]+) - $2. тобто ця функція додає тире, штрихи та змінює  порядки
console.log("Після заміни: " + res); */

//Ще кілька слів про дужні групи
/* var str = "Великий і жахливий Вася Пупкін вийшов на ґанок";
var re = /(Вася) (Пупкін)/;
console.log("Зразок: " + str);
// var res = str.replace(re, "$2 $1");

// var res = str.replace(re, "$1 $`"); // Частина рядка до збігу (символ ` над Ё) !!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//var res = str.replace(re, "$1 _$'_"); // Частина рядка після збігу
// var res = str.replace(re, "$1 _$&_"); //Збіг цілком

console.log(res); */


//Якщо скобочна група потрібна нам тільки для угруповання елементів і ми не хочемо "запам'ятовувати" її, спочатку потрібно поставити умовний знак "?:" (Так, знову він):
/* var str = "Великий і жахливий Петя Пяточкін вийшов на ґанок";
var re = /(?:Вася|Петя) (?:Пупкін|Пяточкін)/; //У цьому випадку регулярний вираз шукає входження "Вася Пупкін", "Вася П'яточкін", "Петя Пупкін" або "Петя П'яточкін" у вхідному рядку.
var res = str.match(re);
console.log(res); */


//До речі, split теж вміє працювати з регулярними виразами
/* var str = "миші щури: знову миші, вуші, Суші. ховрахи";
var re = /[:,.]/i;
console.log(str.search(re))
var res = str.split(re);
console.log(res); */

